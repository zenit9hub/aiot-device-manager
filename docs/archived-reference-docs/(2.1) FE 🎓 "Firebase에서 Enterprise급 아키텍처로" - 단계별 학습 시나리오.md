### 📚 학습 목표

  신입 개발자가 **"왜 백엔드가 필요한가?"**를 자연스럽게 이해하고, 실무에서 겪는 확장성 문제를
  해결하는 과정을 체험

  ---
  Phase 1: "빠른 MVP 개발" (현재 FE 프로젝트)

  🚀 Firebase-Only 아키텍처의 장점 체험

  시나리오: "스타트업에서 IoT 디바이스 관리 서비스를 빠르게 런칭해야 하는 상황!!"

  Frontend ← Firebase Auth ← Firestore
           ↑
        "서버 없이 모든 게 가능!"

  배우는 것들:
  - ✅ 빠른 개발: 서버 구축 없이 인증 + 실시간 DB
  - ✅ 실시간 동기화: Firestore onSnapshot의 마법
  - ✅ 자동 스케일링: Firebase 자동 관리
  - ✅ 비용 효율: 사용량 기반 과금

  체험한 것들:
  - Google OAuth 로그인 구현
  - 실시간 디바이스 상태 동기화
  - 사용자별 데이터 격리
  - Firebase Security Rules

  ---
  Phase 2: "현실의 벽 - 한계 체험"

  🚨 Firebase-Only의 한계 시뮬레이션

  시나리오: "서비스가 성장하면서 문제들이 생기기 시작합니다..."

  문제 상황들:

  1. 비즈니스 로직의 한계
  // 😅 Frontend에서만 가능한 것들...
  if (device.batteryLevel < 20) {
    // 알림을 보내고 싶은데... 클라이언트가 꺼져있으면?
    // 이메일을 보내고 싶은데... API Key를 어디에?
  }

  2. 데이터 분석의 어려움
  // 😅 복잡한 통계는 어떻게...?
  // "지난 3개월간 배터리 교체 주기별 사용자 분류"
  // Firestore 쿼리 제한에 막힘

  3. 외부 시스템 연동
  // 😅 ERP 시스템과 연동하고 싶은데...
  // 회계팀에서 월별 디바이스 사용 비용을 원하는데...
  // Firestore만으로는 불가능!

  4. 감사(Audit) 로그
  // 😅 "누가 언제 무엇을 했는지" 추적하고 싶은데...
  // Firebase에서는 한계가...

  ---
  Phase 3: "Enterprise급 아키텍처 도입"

  🏗️ Backend API + RDS 연동으로 문제 해결

  시나리오: "이제 진짜 확장 가능한 시스템을 만들어봅시다!"

  Frontend ← Firebase Auth ← NestJS Backend ← PostgreSQL
           ↑                      ↓
        Firestore              External APIs
      (실시간 데이터)           (ERP, Email, etc.)

  해결되는 문제들:

  1. 하이브리드 데이터 전략
  // ✅ 각자의 장점을 활용!
  // Firestore: 실시간성이 중요한 데이터
  - 디바이스 온라인/오프라인 상태
  - 실시간 센서 데이터
  - 즉시 알림

  // PostgreSQL: 관계형이 중요한 데이터  
  - 사용자 프로필 & 권한 관리
  - 디바이스 소유권 관계
  - 사용 통계 & 분석 데이터
  - 감사 로그

  2. 서버사이드 비즈니스 로직
  // ✅ 백엔드에서 안전하게!
  @Cron('0 */6 * * *') // 6시간마다
  async checkLowBattery() {
    const devices = await this.deviceService.getLowBatteryDevices();
    for (const device of devices) {
      await this.emailService.sendAlert(device.owner.email);
      await this.logService.createAuditLog('LOW_BATTERY_ALERT', device.id);
    }
  }

  3. 복잡한 데이터 분석
  // ✅ SQL의 힘!
  @Get('/analytics/battery-replacement-cycle')
  async getBatteryAnalytics() {
    return await this.db.query(`
      SELECT 
        battery_replacement_interval,
        COUNT(*) as user_count,
        AVG(usage_hours) as avg_usage
      FROM device_analytics 
      WHERE created_at > NOW() - INTERVAL '3 months'
      GROUP BY battery_replacement_interval
      ORDER BY user_count DESC
    `);
  }

  4. 외부 시스템 연동
  // ✅ 안전한 API 통합!
  @Post('/devices/:id/maintenance')
  async scheduleMainte나ce(@Param('id') deviceId: string) {
    // 1. 디바이스 정보 확인
    const device = await this.deviceService.findById(deviceId);

    // 2. ERP 시스템에 정비 요청
    await this.erpService.createMaintenanceOrder(device);

    // 3. 사용자에게 알림
    await this.notificationService.send(device.userId, '정비 예약됨');

    // 4. 감사 로그 기록
    await this.auditService.log('MAINTENANCE_SCHEDULED', deviceId);
  }

  ---
  🎯 학습자가 얻는 깨달음들

  5. 아키텍처 진화의 자연스러운 흐름

  개인 프로젝트 → MVP → 성장 → 확장성 문제 → Enterprise급 해결
     Firebase    →     →      →       →      Backend + DB

  6. "적절한 도구를 적절한 곳에"

  - Firestore: 실시간 동기화가 필요한 곳
  - PostgreSQL: 복잡한 관계와 분석이 필요한 곳
  - Backend API: 보안과 비즈니스 로직이 필요한 곳

  3. 실무 스킬의 자연스러운 습득

  - Firebase → NestJS → TypeORM → PostgreSQL
  - 인증 → API 설계 → 데이터 모델링 → 배포

  4. 비용 대비 효과

  Phase 1: 빠른 개발 + 저비용 (Firebase)
  Phase 2: 한계 체험 (현실적 제약 사항)
  Phase 3: 확장성 확보 + 전문성 (Backend + RDS)

  ---
  🚀 실제 강의/멘토링 시나리오

  Week 1-2: "Firebase의 마법"

  - "서버 없이도 이런 게 가능해!"
  - 실시간 동기화의 놀라움 체험
  - 빠른 프로토타입 완성의 희열

  Week 3-4: "현실의 제약"

  - "어? 이걸 어떻게 하지?"
  - Firebase의 한계 상황들 체험
  - "백엔드가 왜 필요한지 알겠다!"

  Week 5-8: "전문적 해결책"

  - NestJS로 확장 가능한 아키텍처 구축
  - 하이브리드 데이터베이스 전략 실습
  - Enterprise급 기능들 구현

  마무리: "아키텍처 설계 철학"

  - 언제 Firebase만 써도 될까?
  - 언제 Backend가 필요할까?
  - 실무에서 어떻게 판단할까?

  이 시나리오는 **"왜?"**라는 질문에 명확한 **"경험"**으로 답을 주는 강력한 학습 여정입니다! 🎓
